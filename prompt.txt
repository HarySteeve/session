J'ai un projet avec cette arborescence:
C:.
│   docker-compose.yml
│   name.md
│   README.md
│   run.sh
│
├───haproxy
│       haproxy.cfg
│
├───mysql_conf
│       Dockerfile
│       node1.cnf
│       node2.cnf
│
└───serverA
    │   base.sql
    │   Dockerfile
    │   index.php
    │
    ├───backend
    │       init.php
    │       MySessionHandler.php
    │       traitement.php
    │
    └───pages
            index.php

le projet consiste redistribuer des clients sur differentes serveurs via haproxy. Un client est redistribue vers plusieurs serveurs web via haproxy et de meme, chaque serveur lorsqu'ils font des requettes sql, leur requette est redistribue vers d'autre serveurs sgbd. Voici la configuration du haproxy:
global
    log stdout format raw local0

defaults
    log     global
    mode    http
    option  httplog
    timeout connect 5s
    timeout client  50s
    timeout server  50s

# php
frontend http_in
    bind *:8080
    default_backend web_servers

backend web_servers
    balance roundrobin
    option httpchk GET /
    server web1 server_1:8000 check
    server web2 server_2:8000 check

# mysql
frontend mysql_front
    bind *:3306
    mode tcp
    default_backend mysql_servers
    timeout client  1m
    timeout server  1m

backend mysql_servers
    mode tcp
    balance roundrobin
    timeout connect 5s
    timeout server 1m
    timeout client 1m
    server mysql1 mysql_db_1:3306 check
    server mysql2 mysql_db_2:3306 check
Et le contenu de docker-compose.yml:
services:
  mysql_db_1:
    build:
      context: ./mysql_conf
      dockerfile: Dockerfile
      args:
        CONFIG: node1.cnf
    container_name: mysql_db_1
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: session_db
      MYSQL_USER: user
      MYSQL_PASSWORD: userpass
    volumes:
      - mysql_data_1:/var/lib/mysql
    ports:
      - "3306:3306"

  mysql_db_2:
    build:
      context: ./mysql_conf
      dockerfile: Dockerfile
      args:
        CONFIG: node2.cnf
    container_name: mysql_db_2
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: session_db
      # Should Not create the application user on this replica during init
      # It will be created once on mysql_db_1 and replicated via GTID
    volumes:
      - mysql_data_2:/var/lib/mysql
    ports:
      - "3307:3306"

  server_1:
    build: ./serverA
    container_name: server_1
    ports:
      - "8001:8000"
    volumes:
    - ./serverA:/var/www/html
    environment:
      - DB_HOST=mysql
      - DB_USER=user
      - DB_PASSWORD=userpass
      - DB_NAME=session_db

  server_2:
    build: ./serverA
    container_name: server_2
    ports:
      - "8002:8000"
    volumes:
      - ./serverA:/var/www/html
    environment:
      - DB_HOST=mysql
      - DB_USER=user
      - DB_PASSWORD=userpass
      - DB_NAME=session_db

  haproxy:
    image: haproxy:latest
    container_name: haproxy
    ports:
      - "8080:8080"
      - "33066:3306"
    depends_on:
      - mysql_db_1
      - mysql_db_2
      - server_1
      - server_2
    volumes:
      - ./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg:ro

volumes:
  mysql_data_1:
  mysql_data_2:
Pour info, les deux serveurs ont cette configuration:
node1.cnf:
[mysqld]
server_id = 101
log_bin = mysql-bin
binlog_format = ROW
gtid_mode = ON
enforce_gtid_consistency = ON
log_slave_updates = ON
master_info_repository = TABLE
relay_log_info_repository = TABLE
sync_binlog = 1
auto_increment_increment = 2
auto_increment_offset = 1
node2.cnf:
[mysqld]
server_id = 102
log_bin = mysql-bin
binlog_format = ROW
gtid_mode = ON
enforce_gtid_consistency = ON
log_slave_updates = ON
master_info_repository = TABLE
relay_log_info_repository = TABLE
sync_binlog = 1
auto_increment_increment = 2
auto_increment_offset = 2
Et la configuration de chaque serveur db sur la replication se fait dans cette run.sh:
#!/usr/bin/env bash
set -euo pipefail

docker compose down -v
docker compose build || true
docker compose up -d

wait_for() {
  svc="$1"
  echo "waiting for $svc mysqld..."
  # Use mysqladmin ping over TCP to avoid socket path issues inside the container
  until docker exec "$svc" mysqladmin ping -h127.0.0.1 -uroot -proot --silent >/dev/null 2>&1; do
    echo "waiting for $svc..."
    sleep 1
  done
}

wait_for mysql_db_1
wait_for mysql_db_2

# Create replication user (TCP: 3306 mysql_native_password)
docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "DROP USER IF EXISTS 'repl'@'%'; CREATE USER 'repl'@'%' IDENTIFIED WITH mysql_native_password BY 'replpass'; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'; FLUSH PRIVILEGES;"
docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "DROP USER IF EXISTS 'repl'@'%'; CREATE USER 'repl'@'%' IDENTIFIED WITH mysql_native_password BY 'replpass'; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'; FLUSH PRIVILEGES;"

# Copy SQL into primary only to avoid creating the same user twice on both servers
# NOTE: We want the application user and schema created once and then propagated by GTID
docker cp serverA/base.sql mysql_db_1:/tmp/base.sql || true
docker exec -i mysql_db_1 sh -c "mysql -h127.0.0.1 -P3306 -uroot -proot < /tmp/base.sql"

sleep 1

# Ensure test table exists (avoid situation where import finishes slightly later)
echo "waiting for session_db.test_sync_table to exist on mysql_db_1..."
tries=0
until docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SHOW TABLES FROM session_db LIKE 'test_sync_table'" >/dev/null 2>&1 || [ $tries -ge 15 ]; do
  echo "waiting for table... ($tries)"
  sleep 1
  tries=$((tries+1))
done

# Reset and configure GTID auto-positioning master to master (TCP)
docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "STOP SLAVE; RESET SLAVE ALL; CHANGE MASTER TO MASTER_HOST='mysql_db_2', MASTER_USER='repl', MASTER_PASSWORD='replpass', MASTER_AUTO_POSITION=1; START SLAVE;"
docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "STOP SLAVE; RESET SLAVE ALL; CHANGE MASTER TO MASTER_HOST='mysql_db_1', MASTER_USER='repl', MASTER_PASSWORD='replpass', MASTER_AUTO_POSITION=1; START SLAVE;"

# Status
docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SHOW SLAVE STATUS\G" || true
docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SHOW SLAVE STATUS\G" || true

echo "replication setup script finished"

# Replication test
echo "running simple replication test: insert row on mysql_db_1, check on mysql_db_2"
docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "INSERT INTO session_db.test_sync_table (value) VALUES ('test-from-1');"
try=0
until docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SELECT id,value FROM session_db.test_sync_table WHERE value='test-from-1'\G" | grep -q "test-from-1" || [ $try -ge 10 ]; do
  echo "waiting for row to replicate to mysql_db_2... ($try)"
  sleep 1
  try=$((try+1))
done
docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SELECT id,value FROM session_db.test_sync_table WHERE value='test-from-1'\G" || true

echo "running simple replication test: insert row on mysql_db_2, check on mysql_db_1"
docker exec -i mysql_db_2 mysql -h127.0.0.1 -P3306 -uroot -proot -e "INSERT INTO session_db.test_sync_table (value) VALUES ('test-from-2');"
try=0
until docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SELECT id,value FROM session_db.test_sync_table WHERE value='test-from-2'\G" | grep -q "test-from-2" || [ $try -ge 10 ]; do
  echo "waiting for row to replicate to mysql_db_1... ($try)"
  sleep 1
  try=$((try+1))
done
docker exec -i mysql_db_1 mysql -h127.0.0.1 -P3306 -uroot -proot -e "SELECT id,value FROM session_db.test_sync_table WHERE value='test-from-2'\G" || true

echo "replication test finished"

Mon objectif est ceci: je veux creer une interface web qui me permet d'ajouter un nouveau serveur de base de donnee. Pourrais tu me montrer comment faire cela. Et j'ai une question. Quels sont toutes les actions possible que haproxy peut faire pour la facon de redistribuer les requettes vers les serveurs? Je veux dire qu'il y a par exemple roudbonding et quels sont aussi les autres? En effet je veux les mettre aussi dans l'interface

J'ai des questions:
1) pour la Partie 1 : Interface web pour ajouter dynamiquement un nouveau serveur de base de données
est ce que mon backend ne doit pas aussi modifier automatiquement le fichier run.sh. Parce que dedans, il y a le plugin de configuration du replication entre mysql_db1, mysql_db_2 et mysql_db_3 par exemple